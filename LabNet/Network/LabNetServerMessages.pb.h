// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LabNetServerMessages.proto

#ifndef PROTOBUF_INCLUDED_LabNetServerMessages_2eproto
#define PROTOBUF_INCLUDED_LabNetServerMessages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_LabNetServerMessages_2eproto 

namespace protobuf_LabNetServerMessages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_LabNetServerMessages_2eproto
namespace LabNet {
namespace Messages {
namespace Server {
class GpioDigitalInInitResult;
class GpioDigitalInInitResultDefaultTypeInternal;
extern GpioDigitalInInitResultDefaultTypeInternal _GpioDigitalInInitResult_default_instance_;
class GpioDigitalInState;
class GpioDigitalInStateDefaultTypeInternal;
extern GpioDigitalInStateDefaultTypeInternal _GpioDigitalInState_default_instance_;
class GpioDigitalOutInitResult;
class GpioDigitalOutInitResultDefaultTypeInternal;
extern GpioDigitalOutInitResultDefaultTypeInternal _GpioDigitalOutInitResult_default_instance_;
class GpioDigitalOutState;
class GpioDigitalOutStateDefaultTypeInternal;
extern GpioDigitalOutStateDefaultTypeInternal _GpioDigitalOutState_default_instance_;
class GpioInitResult;
class GpioInitResultDefaultTypeInternal;
extern GpioInitResultDefaultTypeInternal _GpioInitResult_default_instance_;
class OnlyOneConnectionAllowed;
class OnlyOneConnectionAllowedDefaultTypeInternal;
extern OnlyOneConnectionAllowedDefaultTypeInternal _OnlyOneConnectionAllowed_default_instance_;
class Sam32InitResult;
class Sam32InitResultDefaultTypeInternal;
extern Sam32InitResultDefaultTypeInternal _Sam32InitResult_default_instance_;
class ServerWrappedMessage;
class ServerWrappedMessageDefaultTypeInternal;
extern ServerWrappedMessageDefaultTypeInternal _ServerWrappedMessage_default_instance_;
class UartInitResult;
class UartInitResultDefaultTypeInternal;
extern UartInitResultDefaultTypeInternal _UartInitResult_default_instance_;
class UartNewData;
class UartNewDataDefaultTypeInternal;
extern UartNewDataDefaultTypeInternal _UartNewData_default_instance_;
class UartWriteDataComplete;
class UartWriteDataCompleteDefaultTypeInternal;
extern UartWriteDataCompleteDefaultTypeInternal _UartWriteDataComplete_default_instance_;
}  // namespace Server
}  // namespace Messages
}  // namespace LabNet
namespace google {
namespace protobuf {
template<> ::LabNet::Messages::Server::GpioDigitalInInitResult* Arena::CreateMaybeMessage<::LabNet::Messages::Server::GpioDigitalInInitResult>(Arena*);
template<> ::LabNet::Messages::Server::GpioDigitalInState* Arena::CreateMaybeMessage<::LabNet::Messages::Server::GpioDigitalInState>(Arena*);
template<> ::LabNet::Messages::Server::GpioDigitalOutInitResult* Arena::CreateMaybeMessage<::LabNet::Messages::Server::GpioDigitalOutInitResult>(Arena*);
template<> ::LabNet::Messages::Server::GpioDigitalOutState* Arena::CreateMaybeMessage<::LabNet::Messages::Server::GpioDigitalOutState>(Arena*);
template<> ::LabNet::Messages::Server::GpioInitResult* Arena::CreateMaybeMessage<::LabNet::Messages::Server::GpioInitResult>(Arena*);
template<> ::LabNet::Messages::Server::OnlyOneConnectionAllowed* Arena::CreateMaybeMessage<::LabNet::Messages::Server::OnlyOneConnectionAllowed>(Arena*);
template<> ::LabNet::Messages::Server::Sam32InitResult* Arena::CreateMaybeMessage<::LabNet::Messages::Server::Sam32InitResult>(Arena*);
template<> ::LabNet::Messages::Server::ServerWrappedMessage* Arena::CreateMaybeMessage<::LabNet::Messages::Server::ServerWrappedMessage>(Arena*);
template<> ::LabNet::Messages::Server::UartInitResult* Arena::CreateMaybeMessage<::LabNet::Messages::Server::UartInitResult>(Arena*);
template<> ::LabNet::Messages::Server::UartNewData* Arena::CreateMaybeMessage<::LabNet::Messages::Server::UartNewData>(Arena*);
template<> ::LabNet::Messages::Server::UartWriteDataComplete* Arena::CreateMaybeMessage<::LabNet::Messages::Server::UartWriteDataComplete>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace LabNet {
namespace Messages {
namespace Server {

// ===================================================================

class GpioInitResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.GpioInitResult) */ {
 public:
  GpioInitResult();
  virtual ~GpioInitResult();

  GpioInitResult(const GpioInitResult& from);

  inline GpioInitResult& operator=(const GpioInitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioInitResult(GpioInitResult&& from) noexcept
    : GpioInitResult() {
    *this = ::std::move(from);
  }

  inline GpioInitResult& operator=(GpioInitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioInitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioInitResult* internal_default_instance() {
    return reinterpret_cast<const GpioInitResult*>(
               &_GpioInitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GpioInitResult* other);
  friend void swap(GpioInitResult& a, GpioInitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioInitResult* New() const final {
    return CreateMaybeMessage<GpioInitResult>(NULL);
  }

  GpioInitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpioInitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GpioInitResult& from);
  void MergeFrom(const GpioInitResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpioInitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_succeed = 1;
  void clear_is_succeed();
  static const int kIsSucceedFieldNumber = 1;
  bool is_succeed() const;
  void set_is_succeed(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.GpioInitResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_succeed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GpioDigitalInInitResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.GpioDigitalInInitResult) */ {
 public:
  GpioDigitalInInitResult();
  virtual ~GpioDigitalInInitResult();

  GpioDigitalInInitResult(const GpioDigitalInInitResult& from);

  inline GpioDigitalInInitResult& operator=(const GpioDigitalInInitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioDigitalInInitResult(GpioDigitalInInitResult&& from) noexcept
    : GpioDigitalInInitResult() {
    *this = ::std::move(from);
  }

  inline GpioDigitalInInitResult& operator=(GpioDigitalInInitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioDigitalInInitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioDigitalInInitResult* internal_default_instance() {
    return reinterpret_cast<const GpioDigitalInInitResult*>(
               &_GpioDigitalInInitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GpioDigitalInInitResult* other);
  friend void swap(GpioDigitalInInitResult& a, GpioDigitalInInitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioDigitalInInitResult* New() const final {
    return CreateMaybeMessage<GpioDigitalInInitResult>(NULL);
  }

  GpioDigitalInInitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpioDigitalInInitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GpioDigitalInInitResult& from);
  void MergeFrom(const GpioDigitalInInitResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpioDigitalInInitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pin = 1;
  void clear_pin();
  static const int kPinFieldNumber = 1;
  ::google::protobuf::uint32 pin() const;
  void set_pin(::google::protobuf::uint32 value);

  // bool is_succeed = 2;
  void clear_is_succeed();
  static const int kIsSucceedFieldNumber = 2;
  bool is_succeed() const;
  void set_is_succeed(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.GpioDigitalInInitResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pin_;
  bool is_succeed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GpioDigitalOutInitResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.GpioDigitalOutInitResult) */ {
 public:
  GpioDigitalOutInitResult();
  virtual ~GpioDigitalOutInitResult();

  GpioDigitalOutInitResult(const GpioDigitalOutInitResult& from);

  inline GpioDigitalOutInitResult& operator=(const GpioDigitalOutInitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioDigitalOutInitResult(GpioDigitalOutInitResult&& from) noexcept
    : GpioDigitalOutInitResult() {
    *this = ::std::move(from);
  }

  inline GpioDigitalOutInitResult& operator=(GpioDigitalOutInitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioDigitalOutInitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioDigitalOutInitResult* internal_default_instance() {
    return reinterpret_cast<const GpioDigitalOutInitResult*>(
               &_GpioDigitalOutInitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GpioDigitalOutInitResult* other);
  friend void swap(GpioDigitalOutInitResult& a, GpioDigitalOutInitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioDigitalOutInitResult* New() const final {
    return CreateMaybeMessage<GpioDigitalOutInitResult>(NULL);
  }

  GpioDigitalOutInitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpioDigitalOutInitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GpioDigitalOutInitResult& from);
  void MergeFrom(const GpioDigitalOutInitResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpioDigitalOutInitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pin = 1;
  void clear_pin();
  static const int kPinFieldNumber = 1;
  ::google::protobuf::uint32 pin() const;
  void set_pin(::google::protobuf::uint32 value);

  // bool is_succeed = 2;
  void clear_is_succeed();
  static const int kIsSucceedFieldNumber = 2;
  bool is_succeed() const;
  void set_is_succeed(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.GpioDigitalOutInitResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pin_;
  bool is_succeed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GpioDigitalOutState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.GpioDigitalOutState) */ {
 public:
  GpioDigitalOutState();
  virtual ~GpioDigitalOutState();

  GpioDigitalOutState(const GpioDigitalOutState& from);

  inline GpioDigitalOutState& operator=(const GpioDigitalOutState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioDigitalOutState(GpioDigitalOutState&& from) noexcept
    : GpioDigitalOutState() {
    *this = ::std::move(from);
  }

  inline GpioDigitalOutState& operator=(GpioDigitalOutState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioDigitalOutState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioDigitalOutState* internal_default_instance() {
    return reinterpret_cast<const GpioDigitalOutState*>(
               &_GpioDigitalOutState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GpioDigitalOutState* other);
  friend void swap(GpioDigitalOutState& a, GpioDigitalOutState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioDigitalOutState* New() const final {
    return CreateMaybeMessage<GpioDigitalOutState>(NULL);
  }

  GpioDigitalOutState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpioDigitalOutState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GpioDigitalOutState& from);
  void MergeFrom(const GpioDigitalOutState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpioDigitalOutState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pin = 1;
  void clear_pin();
  static const int kPinFieldNumber = 1;
  ::google::protobuf::uint32 pin() const;
  void set_pin(::google::protobuf::uint32 value);

  // bool state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.GpioDigitalOutState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pin_;
  bool state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GpioDigitalInState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.GpioDigitalInState) */ {
 public:
  GpioDigitalInState();
  virtual ~GpioDigitalInState();

  GpioDigitalInState(const GpioDigitalInState& from);

  inline GpioDigitalInState& operator=(const GpioDigitalInState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GpioDigitalInState(GpioDigitalInState&& from) noexcept
    : GpioDigitalInState() {
    *this = ::std::move(from);
  }

  inline GpioDigitalInState& operator=(GpioDigitalInState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GpioDigitalInState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GpioDigitalInState* internal_default_instance() {
    return reinterpret_cast<const GpioDigitalInState*>(
               &_GpioDigitalInState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GpioDigitalInState* other);
  friend void swap(GpioDigitalInState& a, GpioDigitalInState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GpioDigitalInState* New() const final {
    return CreateMaybeMessage<GpioDigitalInState>(NULL);
  }

  GpioDigitalInState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GpioDigitalInState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GpioDigitalInState& from);
  void MergeFrom(const GpioDigitalInState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpioDigitalInState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 pin = 1;
  void clear_pin();
  static const int kPinFieldNumber = 1;
  ::google::protobuf::uint32 pin() const;
  void set_pin(::google::protobuf::uint32 value);

  // bool state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  bool state() const;
  void set_state(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.GpioDigitalInState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 pin_;
  bool state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sam32InitResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.Sam32InitResult) */ {
 public:
  Sam32InitResult();
  virtual ~Sam32InitResult();

  Sam32InitResult(const Sam32InitResult& from);

  inline Sam32InitResult& operator=(const Sam32InitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sam32InitResult(Sam32InitResult&& from) noexcept
    : Sam32InitResult() {
    *this = ::std::move(from);
  }

  inline Sam32InitResult& operator=(Sam32InitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sam32InitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sam32InitResult* internal_default_instance() {
    return reinterpret_cast<const Sam32InitResult*>(
               &_Sam32InitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Sam32InitResult* other);
  friend void swap(Sam32InitResult& a, Sam32InitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sam32InitResult* New() const final {
    return CreateMaybeMessage<Sam32InitResult>(NULL);
  }

  Sam32InitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sam32InitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sam32InitResult& from);
  void MergeFrom(const Sam32InitResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sam32InitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_succeed = 1;
  void clear_is_succeed();
  static const int kIsSucceedFieldNumber = 1;
  bool is_succeed() const;
  void set_is_succeed(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.Sam32InitResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_succeed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UartInitResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.UartInitResult) */ {
 public:
  UartInitResult();
  virtual ~UartInitResult();

  UartInitResult(const UartInitResult& from);

  inline UartInitResult& operator=(const UartInitResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UartInitResult(UartInitResult&& from) noexcept
    : UartInitResult() {
    *this = ::std::move(from);
  }

  inline UartInitResult& operator=(UartInitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UartInitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UartInitResult* internal_default_instance() {
    return reinterpret_cast<const UartInitResult*>(
               &_UartInitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UartInitResult* other);
  friend void swap(UartInitResult& a, UartInitResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UartInitResult* New() const final {
    return CreateMaybeMessage<UartInitResult>(NULL);
  }

  UartInitResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UartInitResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UartInitResult& from);
  void MergeFrom(const UartInitResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UartInitResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 port_id = 1;
  void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  ::google::protobuf::uint32 port_id() const;
  void set_port_id(::google::protobuf::uint32 value);

  // bool is_succeed = 2;
  void clear_is_succeed();
  static const int kIsSucceedFieldNumber = 2;
  bool is_succeed() const;
  void set_is_succeed(bool value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.UartInitResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 port_id_;
  bool is_succeed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UartNewData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.UartNewData) */ {
 public:
  UartNewData();
  virtual ~UartNewData();

  UartNewData(const UartNewData& from);

  inline UartNewData& operator=(const UartNewData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UartNewData(UartNewData&& from) noexcept
    : UartNewData() {
    *this = ::std::move(from);
  }

  inline UartNewData& operator=(UartNewData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UartNewData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UartNewData* internal_default_instance() {
    return reinterpret_cast<const UartNewData*>(
               &_UartNewData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UartNewData* other);
  friend void swap(UartNewData& a, UartNewData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UartNewData* New() const final {
    return CreateMaybeMessage<UartNewData>(NULL);
  }

  UartNewData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UartNewData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UartNewData& from);
  void MergeFrom(const UartNewData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UartNewData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 port_id = 1;
  void clear_port_id();
  static const int kPortIdFieldNumber = 1;
  ::google::protobuf::uint32 port_id() const;
  void set_port_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.UartNewData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 port_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UartWriteDataComplete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.UartWriteDataComplete) */ {
 public:
  UartWriteDataComplete();
  virtual ~UartWriteDataComplete();

  UartWriteDataComplete(const UartWriteDataComplete& from);

  inline UartWriteDataComplete& operator=(const UartWriteDataComplete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UartWriteDataComplete(UartWriteDataComplete&& from) noexcept
    : UartWriteDataComplete() {
    *this = ::std::move(from);
  }

  inline UartWriteDataComplete& operator=(UartWriteDataComplete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UartWriteDataComplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UartWriteDataComplete* internal_default_instance() {
    return reinterpret_cast<const UartWriteDataComplete*>(
               &_UartWriteDataComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(UartWriteDataComplete* other);
  friend void swap(UartWriteDataComplete& a, UartWriteDataComplete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UartWriteDataComplete* New() const final {
    return CreateMaybeMessage<UartWriteDataComplete>(NULL);
  }

  UartWriteDataComplete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UartWriteDataComplete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UartWriteDataComplete& from);
  void MergeFrom(const UartWriteDataComplete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UartWriteDataComplete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 portId = 1;
  void clear_portid();
  static const int kPortIdFieldNumber = 1;
  ::google::protobuf::uint32 portid() const;
  void set_portid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.UartWriteDataComplete)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 portid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OnlyOneConnectionAllowed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.OnlyOneConnectionAllowed) */ {
 public:
  OnlyOneConnectionAllowed();
  virtual ~OnlyOneConnectionAllowed();

  OnlyOneConnectionAllowed(const OnlyOneConnectionAllowed& from);

  inline OnlyOneConnectionAllowed& operator=(const OnlyOneConnectionAllowed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OnlyOneConnectionAllowed(OnlyOneConnectionAllowed&& from) noexcept
    : OnlyOneConnectionAllowed() {
    *this = ::std::move(from);
  }

  inline OnlyOneConnectionAllowed& operator=(OnlyOneConnectionAllowed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlyOneConnectionAllowed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnlyOneConnectionAllowed* internal_default_instance() {
    return reinterpret_cast<const OnlyOneConnectionAllowed*>(
               &_OnlyOneConnectionAllowed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(OnlyOneConnectionAllowed* other);
  friend void swap(OnlyOneConnectionAllowed& a, OnlyOneConnectionAllowed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnlyOneConnectionAllowed* New() const final {
    return CreateMaybeMessage<OnlyOneConnectionAllowed>(NULL);
  }

  OnlyOneConnectionAllowed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OnlyOneConnectionAllowed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OnlyOneConnectionAllowed& from);
  void MergeFrom(const OnlyOneConnectionAllowed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnlyOneConnectionAllowed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.OnlyOneConnectionAllowed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerWrappedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LabNet.Messages.Server.ServerWrappedMessage) */ {
 public:
  ServerWrappedMessage();
  virtual ~ServerWrappedMessage();

  ServerWrappedMessage(const ServerWrappedMessage& from);

  inline ServerWrappedMessage& operator=(const ServerWrappedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerWrappedMessage(ServerWrappedMessage&& from) noexcept
    : ServerWrappedMessage() {
    *this = ::std::move(from);
  }

  inline ServerWrappedMessage& operator=(ServerWrappedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerWrappedMessage& default_instance();

  enum ServerMessageCase {
    kGpioInitResult = 1,
    kGpioDigitalInInitResult = 2,
    kGpioDigitalOutInitResult = 3,
    kGpioDigitalOutState = 4,
    kGpioDigitalInState = 5,
    kSam32InitResult = 6,
    kUartInitResult = 7,
    kUartNewData = 8,
    kUartWriteDataComplete = 9,
    kOnlyOneConnection = 10,
    SERVER_MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerWrappedMessage* internal_default_instance() {
    return reinterpret_cast<const ServerWrappedMessage*>(
               &_ServerWrappedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ServerWrappedMessage* other);
  friend void swap(ServerWrappedMessage& a, ServerWrappedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerWrappedMessage* New() const final {
    return CreateMaybeMessage<ServerWrappedMessage>(NULL);
  }

  ServerWrappedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerWrappedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerWrappedMessage& from);
  void MergeFrom(const ServerWrappedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerWrappedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .LabNet.Messages.Server.GpioInitResult gpio_init_result = 1;
  bool has_gpio_init_result() const;
  void clear_gpio_init_result();
  static const int kGpioInitResultFieldNumber = 1;
  private:
  const ::LabNet::Messages::Server::GpioInitResult& _internal_gpio_init_result() const;
  public:
  const ::LabNet::Messages::Server::GpioInitResult& gpio_init_result() const;
  ::LabNet::Messages::Server::GpioInitResult* release_gpio_init_result();
  ::LabNet::Messages::Server::GpioInitResult* mutable_gpio_init_result();
  void set_allocated_gpio_init_result(::LabNet::Messages::Server::GpioInitResult* gpio_init_result);

  // .LabNet.Messages.Server.GpioDigitalInInitResult gpio_digital_in_init_result = 2;
  bool has_gpio_digital_in_init_result() const;
  void clear_gpio_digital_in_init_result();
  static const int kGpioDigitalInInitResultFieldNumber = 2;
  private:
  const ::LabNet::Messages::Server::GpioDigitalInInitResult& _internal_gpio_digital_in_init_result() const;
  public:
  const ::LabNet::Messages::Server::GpioDigitalInInitResult& gpio_digital_in_init_result() const;
  ::LabNet::Messages::Server::GpioDigitalInInitResult* release_gpio_digital_in_init_result();
  ::LabNet::Messages::Server::GpioDigitalInInitResult* mutable_gpio_digital_in_init_result();
  void set_allocated_gpio_digital_in_init_result(::LabNet::Messages::Server::GpioDigitalInInitResult* gpio_digital_in_init_result);

  // .LabNet.Messages.Server.GpioDigitalOutInitResult gpio_digital_out_init_result = 3;
  bool has_gpio_digital_out_init_result() const;
  void clear_gpio_digital_out_init_result();
  static const int kGpioDigitalOutInitResultFieldNumber = 3;
  private:
  const ::LabNet::Messages::Server::GpioDigitalOutInitResult& _internal_gpio_digital_out_init_result() const;
  public:
  const ::LabNet::Messages::Server::GpioDigitalOutInitResult& gpio_digital_out_init_result() const;
  ::LabNet::Messages::Server::GpioDigitalOutInitResult* release_gpio_digital_out_init_result();
  ::LabNet::Messages::Server::GpioDigitalOutInitResult* mutable_gpio_digital_out_init_result();
  void set_allocated_gpio_digital_out_init_result(::LabNet::Messages::Server::GpioDigitalOutInitResult* gpio_digital_out_init_result);

  // .LabNet.Messages.Server.GpioDigitalOutState gpio_digital_out_state = 4;
  bool has_gpio_digital_out_state() const;
  void clear_gpio_digital_out_state();
  static const int kGpioDigitalOutStateFieldNumber = 4;
  private:
  const ::LabNet::Messages::Server::GpioDigitalOutState& _internal_gpio_digital_out_state() const;
  public:
  const ::LabNet::Messages::Server::GpioDigitalOutState& gpio_digital_out_state() const;
  ::LabNet::Messages::Server::GpioDigitalOutState* release_gpio_digital_out_state();
  ::LabNet::Messages::Server::GpioDigitalOutState* mutable_gpio_digital_out_state();
  void set_allocated_gpio_digital_out_state(::LabNet::Messages::Server::GpioDigitalOutState* gpio_digital_out_state);

  // .LabNet.Messages.Server.GpioDigitalInState gpio_digital_in_state = 5;
  bool has_gpio_digital_in_state() const;
  void clear_gpio_digital_in_state();
  static const int kGpioDigitalInStateFieldNumber = 5;
  private:
  const ::LabNet::Messages::Server::GpioDigitalInState& _internal_gpio_digital_in_state() const;
  public:
  const ::LabNet::Messages::Server::GpioDigitalInState& gpio_digital_in_state() const;
  ::LabNet::Messages::Server::GpioDigitalInState* release_gpio_digital_in_state();
  ::LabNet::Messages::Server::GpioDigitalInState* mutable_gpio_digital_in_state();
  void set_allocated_gpio_digital_in_state(::LabNet::Messages::Server::GpioDigitalInState* gpio_digital_in_state);

  // .LabNet.Messages.Server.Sam32InitResult sam32_init_result = 6;
  bool has_sam32_init_result() const;
  void clear_sam32_init_result();
  static const int kSam32InitResultFieldNumber = 6;
  private:
  const ::LabNet::Messages::Server::Sam32InitResult& _internal_sam32_init_result() const;
  public:
  const ::LabNet::Messages::Server::Sam32InitResult& sam32_init_result() const;
  ::LabNet::Messages::Server::Sam32InitResult* release_sam32_init_result();
  ::LabNet::Messages::Server::Sam32InitResult* mutable_sam32_init_result();
  void set_allocated_sam32_init_result(::LabNet::Messages::Server::Sam32InitResult* sam32_init_result);

  // .LabNet.Messages.Server.UartInitResult uart_init_result = 7;
  bool has_uart_init_result() const;
  void clear_uart_init_result();
  static const int kUartInitResultFieldNumber = 7;
  private:
  const ::LabNet::Messages::Server::UartInitResult& _internal_uart_init_result() const;
  public:
  const ::LabNet::Messages::Server::UartInitResult& uart_init_result() const;
  ::LabNet::Messages::Server::UartInitResult* release_uart_init_result();
  ::LabNet::Messages::Server::UartInitResult* mutable_uart_init_result();
  void set_allocated_uart_init_result(::LabNet::Messages::Server::UartInitResult* uart_init_result);

  // .LabNet.Messages.Server.UartNewData uart_new_data = 8;
  bool has_uart_new_data() const;
  void clear_uart_new_data();
  static const int kUartNewDataFieldNumber = 8;
  private:
  const ::LabNet::Messages::Server::UartNewData& _internal_uart_new_data() const;
  public:
  const ::LabNet::Messages::Server::UartNewData& uart_new_data() const;
  ::LabNet::Messages::Server::UartNewData* release_uart_new_data();
  ::LabNet::Messages::Server::UartNewData* mutable_uart_new_data();
  void set_allocated_uart_new_data(::LabNet::Messages::Server::UartNewData* uart_new_data);

  // .LabNet.Messages.Server.UartWriteDataComplete uart_write_data_complete = 9;
  bool has_uart_write_data_complete() const;
  void clear_uart_write_data_complete();
  static const int kUartWriteDataCompleteFieldNumber = 9;
  private:
  const ::LabNet::Messages::Server::UartWriteDataComplete& _internal_uart_write_data_complete() const;
  public:
  const ::LabNet::Messages::Server::UartWriteDataComplete& uart_write_data_complete() const;
  ::LabNet::Messages::Server::UartWriteDataComplete* release_uart_write_data_complete();
  ::LabNet::Messages::Server::UartWriteDataComplete* mutable_uart_write_data_complete();
  void set_allocated_uart_write_data_complete(::LabNet::Messages::Server::UartWriteDataComplete* uart_write_data_complete);

  // .LabNet.Messages.Server.OnlyOneConnectionAllowed only_one_connection = 10;
  bool has_only_one_connection() const;
  void clear_only_one_connection();
  static const int kOnlyOneConnectionFieldNumber = 10;
  private:
  const ::LabNet::Messages::Server::OnlyOneConnectionAllowed& _internal_only_one_connection() const;
  public:
  const ::LabNet::Messages::Server::OnlyOneConnectionAllowed& only_one_connection() const;
  ::LabNet::Messages::Server::OnlyOneConnectionAllowed* release_only_one_connection();
  ::LabNet::Messages::Server::OnlyOneConnectionAllowed* mutable_only_one_connection();
  void set_allocated_only_one_connection(::LabNet::Messages::Server::OnlyOneConnectionAllowed* only_one_connection);

  void clear_server_message();
  ServerMessageCase server_message_case() const;
  // @@protoc_insertion_point(class_scope:LabNet.Messages.Server.ServerWrappedMessage)
 private:
  void set_has_gpio_init_result();
  void set_has_gpio_digital_in_init_result();
  void set_has_gpio_digital_out_init_result();
  void set_has_gpio_digital_out_state();
  void set_has_gpio_digital_in_state();
  void set_has_sam32_init_result();
  void set_has_uart_init_result();
  void set_has_uart_new_data();
  void set_has_uart_write_data_complete();
  void set_has_only_one_connection();

  inline bool has_server_message() const;
  inline void clear_has_server_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ServerMessageUnion {
    ServerMessageUnion() {}
    ::LabNet::Messages::Server::GpioInitResult* gpio_init_result_;
    ::LabNet::Messages::Server::GpioDigitalInInitResult* gpio_digital_in_init_result_;
    ::LabNet::Messages::Server::GpioDigitalOutInitResult* gpio_digital_out_init_result_;
    ::LabNet::Messages::Server::GpioDigitalOutState* gpio_digital_out_state_;
    ::LabNet::Messages::Server::GpioDigitalInState* gpio_digital_in_state_;
    ::LabNet::Messages::Server::Sam32InitResult* sam32_init_result_;
    ::LabNet::Messages::Server::UartInitResult* uart_init_result_;
    ::LabNet::Messages::Server::UartNewData* uart_new_data_;
    ::LabNet::Messages::Server::UartWriteDataComplete* uart_write_data_complete_;
    ::LabNet::Messages::Server::OnlyOneConnectionAllowed* only_one_connection_;
  } server_message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_LabNetServerMessages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GpioInitResult

// bool is_succeed = 1;
inline void GpioInitResult::clear_is_succeed() {
  is_succeed_ = false;
}
inline bool GpioInitResult::is_succeed() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioInitResult.is_succeed)
  return is_succeed_;
}
inline void GpioInitResult::set_is_succeed(bool value) {
  
  is_succeed_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioInitResult.is_succeed)
}

// -------------------------------------------------------------------

// GpioDigitalInInitResult

// uint32 pin = 1;
inline void GpioDigitalInInitResult::clear_pin() {
  pin_ = 0u;
}
inline ::google::protobuf::uint32 GpioDigitalInInitResult::pin() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalInInitResult.pin)
  return pin_;
}
inline void GpioDigitalInInitResult::set_pin(::google::protobuf::uint32 value) {
  
  pin_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalInInitResult.pin)
}

// bool is_succeed = 2;
inline void GpioDigitalInInitResult::clear_is_succeed() {
  is_succeed_ = false;
}
inline bool GpioDigitalInInitResult::is_succeed() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalInInitResult.is_succeed)
  return is_succeed_;
}
inline void GpioDigitalInInitResult::set_is_succeed(bool value) {
  
  is_succeed_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalInInitResult.is_succeed)
}

// -------------------------------------------------------------------

// GpioDigitalOutInitResult

// uint32 pin = 1;
inline void GpioDigitalOutInitResult::clear_pin() {
  pin_ = 0u;
}
inline ::google::protobuf::uint32 GpioDigitalOutInitResult::pin() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalOutInitResult.pin)
  return pin_;
}
inline void GpioDigitalOutInitResult::set_pin(::google::protobuf::uint32 value) {
  
  pin_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalOutInitResult.pin)
}

// bool is_succeed = 2;
inline void GpioDigitalOutInitResult::clear_is_succeed() {
  is_succeed_ = false;
}
inline bool GpioDigitalOutInitResult::is_succeed() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalOutInitResult.is_succeed)
  return is_succeed_;
}
inline void GpioDigitalOutInitResult::set_is_succeed(bool value) {
  
  is_succeed_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalOutInitResult.is_succeed)
}

// -------------------------------------------------------------------

// GpioDigitalOutState

// uint32 pin = 1;
inline void GpioDigitalOutState::clear_pin() {
  pin_ = 0u;
}
inline ::google::protobuf::uint32 GpioDigitalOutState::pin() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalOutState.pin)
  return pin_;
}
inline void GpioDigitalOutState::set_pin(::google::protobuf::uint32 value) {
  
  pin_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalOutState.pin)
}

// bool state = 2;
inline void GpioDigitalOutState::clear_state() {
  state_ = false;
}
inline bool GpioDigitalOutState::state() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalOutState.state)
  return state_;
}
inline void GpioDigitalOutState::set_state(bool value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalOutState.state)
}

// -------------------------------------------------------------------

// GpioDigitalInState

// uint32 pin = 1;
inline void GpioDigitalInState::clear_pin() {
  pin_ = 0u;
}
inline ::google::protobuf::uint32 GpioDigitalInState::pin() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalInState.pin)
  return pin_;
}
inline void GpioDigitalInState::set_pin(::google::protobuf::uint32 value) {
  
  pin_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalInState.pin)
}

// bool state = 2;
inline void GpioDigitalInState::clear_state() {
  state_ = false;
}
inline bool GpioDigitalInState::state() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.GpioDigitalInState.state)
  return state_;
}
inline void GpioDigitalInState::set_state(bool value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.GpioDigitalInState.state)
}

// -------------------------------------------------------------------

// Sam32InitResult

// bool is_succeed = 1;
inline void Sam32InitResult::clear_is_succeed() {
  is_succeed_ = false;
}
inline bool Sam32InitResult::is_succeed() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.Sam32InitResult.is_succeed)
  return is_succeed_;
}
inline void Sam32InitResult::set_is_succeed(bool value) {
  
  is_succeed_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.Sam32InitResult.is_succeed)
}

// -------------------------------------------------------------------

// UartInitResult

// uint32 port_id = 1;
inline void UartInitResult::clear_port_id() {
  port_id_ = 0u;
}
inline ::google::protobuf::uint32 UartInitResult::port_id() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.UartInitResult.port_id)
  return port_id_;
}
inline void UartInitResult::set_port_id(::google::protobuf::uint32 value) {
  
  port_id_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.UartInitResult.port_id)
}

// bool is_succeed = 2;
inline void UartInitResult::clear_is_succeed() {
  is_succeed_ = false;
}
inline bool UartInitResult::is_succeed() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.UartInitResult.is_succeed)
  return is_succeed_;
}
inline void UartInitResult::set_is_succeed(bool value) {
  
  is_succeed_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.UartInitResult.is_succeed)
}

// -------------------------------------------------------------------

// UartNewData

// uint32 port_id = 1;
inline void UartNewData::clear_port_id() {
  port_id_ = 0u;
}
inline ::google::protobuf::uint32 UartNewData::port_id() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.UartNewData.port_id)
  return port_id_;
}
inline void UartNewData::set_port_id(::google::protobuf::uint32 value) {
  
  port_id_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.UartNewData.port_id)
}

// bytes data = 2;
inline void UartNewData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UartNewData::data() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.UartNewData.data)
  return data_.GetNoArena();
}
inline void UartNewData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.UartNewData.data)
}
#if LANG_CXX11
inline void UartNewData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LabNet.Messages.Server.UartNewData.data)
}
#endif
inline void UartNewData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LabNet.Messages.Server.UartNewData.data)
}
inline void UartNewData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LabNet.Messages.Server.UartNewData.data)
}
inline ::std::string* UartNewData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.UartNewData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UartNewData::release_data() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.UartNewData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UartNewData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:LabNet.Messages.Server.UartNewData.data)
}

// -------------------------------------------------------------------

// UartWriteDataComplete

// uint32 portId = 1;
inline void UartWriteDataComplete::clear_portid() {
  portid_ = 0u;
}
inline ::google::protobuf::uint32 UartWriteDataComplete::portid() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.UartWriteDataComplete.portId)
  return portid_;
}
inline void UartWriteDataComplete::set_portid(::google::protobuf::uint32 value) {
  
  portid_ = value;
  // @@protoc_insertion_point(field_set:LabNet.Messages.Server.UartWriteDataComplete.portId)
}

// -------------------------------------------------------------------

// OnlyOneConnectionAllowed

// -------------------------------------------------------------------

// ServerWrappedMessage

// .LabNet.Messages.Server.GpioInitResult gpio_init_result = 1;
inline bool ServerWrappedMessage::has_gpio_init_result() const {
  return server_message_case() == kGpioInitResult;
}
inline void ServerWrappedMessage::set_has_gpio_init_result() {
  _oneof_case_[0] = kGpioInitResult;
}
inline void ServerWrappedMessage::clear_gpio_init_result() {
  if (has_gpio_init_result()) {
    delete server_message_.gpio_init_result_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::GpioInitResult& ServerWrappedMessage::_internal_gpio_init_result() const {
  return *server_message_.gpio_init_result_;
}
inline ::LabNet::Messages::Server::GpioInitResult* ServerWrappedMessage::release_gpio_init_result() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.gpio_init_result)
  if (has_gpio_init_result()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::GpioInitResult* temp = server_message_.gpio_init_result_;
    server_message_.gpio_init_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::GpioInitResult& ServerWrappedMessage::gpio_init_result() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.gpio_init_result)
  return has_gpio_init_result()
      ? *server_message_.gpio_init_result_
      : *reinterpret_cast< ::LabNet::Messages::Server::GpioInitResult*>(&::LabNet::Messages::Server::_GpioInitResult_default_instance_);
}
inline ::LabNet::Messages::Server::GpioInitResult* ServerWrappedMessage::mutable_gpio_init_result() {
  if (!has_gpio_init_result()) {
    clear_server_message();
    set_has_gpio_init_result();
    server_message_.gpio_init_result_ = CreateMaybeMessage< ::LabNet::Messages::Server::GpioInitResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.gpio_init_result)
  return server_message_.gpio_init_result_;
}

// .LabNet.Messages.Server.GpioDigitalInInitResult gpio_digital_in_init_result = 2;
inline bool ServerWrappedMessage::has_gpio_digital_in_init_result() const {
  return server_message_case() == kGpioDigitalInInitResult;
}
inline void ServerWrappedMessage::set_has_gpio_digital_in_init_result() {
  _oneof_case_[0] = kGpioDigitalInInitResult;
}
inline void ServerWrappedMessage::clear_gpio_digital_in_init_result() {
  if (has_gpio_digital_in_init_result()) {
    delete server_message_.gpio_digital_in_init_result_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalInInitResult& ServerWrappedMessage::_internal_gpio_digital_in_init_result() const {
  return *server_message_.gpio_digital_in_init_result_;
}
inline ::LabNet::Messages::Server::GpioDigitalInInitResult* ServerWrappedMessage::release_gpio_digital_in_init_result() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_init_result)
  if (has_gpio_digital_in_init_result()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::GpioDigitalInInitResult* temp = server_message_.gpio_digital_in_init_result_;
    server_message_.gpio_digital_in_init_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalInInitResult& ServerWrappedMessage::gpio_digital_in_init_result() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_init_result)
  return has_gpio_digital_in_init_result()
      ? *server_message_.gpio_digital_in_init_result_
      : *reinterpret_cast< ::LabNet::Messages::Server::GpioDigitalInInitResult*>(&::LabNet::Messages::Server::_GpioDigitalInInitResult_default_instance_);
}
inline ::LabNet::Messages::Server::GpioDigitalInInitResult* ServerWrappedMessage::mutable_gpio_digital_in_init_result() {
  if (!has_gpio_digital_in_init_result()) {
    clear_server_message();
    set_has_gpio_digital_in_init_result();
    server_message_.gpio_digital_in_init_result_ = CreateMaybeMessage< ::LabNet::Messages::Server::GpioDigitalInInitResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_init_result)
  return server_message_.gpio_digital_in_init_result_;
}

// .LabNet.Messages.Server.GpioDigitalOutInitResult gpio_digital_out_init_result = 3;
inline bool ServerWrappedMessage::has_gpio_digital_out_init_result() const {
  return server_message_case() == kGpioDigitalOutInitResult;
}
inline void ServerWrappedMessage::set_has_gpio_digital_out_init_result() {
  _oneof_case_[0] = kGpioDigitalOutInitResult;
}
inline void ServerWrappedMessage::clear_gpio_digital_out_init_result() {
  if (has_gpio_digital_out_init_result()) {
    delete server_message_.gpio_digital_out_init_result_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalOutInitResult& ServerWrappedMessage::_internal_gpio_digital_out_init_result() const {
  return *server_message_.gpio_digital_out_init_result_;
}
inline ::LabNet::Messages::Server::GpioDigitalOutInitResult* ServerWrappedMessage::release_gpio_digital_out_init_result() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_init_result)
  if (has_gpio_digital_out_init_result()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::GpioDigitalOutInitResult* temp = server_message_.gpio_digital_out_init_result_;
    server_message_.gpio_digital_out_init_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalOutInitResult& ServerWrappedMessage::gpio_digital_out_init_result() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_init_result)
  return has_gpio_digital_out_init_result()
      ? *server_message_.gpio_digital_out_init_result_
      : *reinterpret_cast< ::LabNet::Messages::Server::GpioDigitalOutInitResult*>(&::LabNet::Messages::Server::_GpioDigitalOutInitResult_default_instance_);
}
inline ::LabNet::Messages::Server::GpioDigitalOutInitResult* ServerWrappedMessage::mutable_gpio_digital_out_init_result() {
  if (!has_gpio_digital_out_init_result()) {
    clear_server_message();
    set_has_gpio_digital_out_init_result();
    server_message_.gpio_digital_out_init_result_ = CreateMaybeMessage< ::LabNet::Messages::Server::GpioDigitalOutInitResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_init_result)
  return server_message_.gpio_digital_out_init_result_;
}

// .LabNet.Messages.Server.GpioDigitalOutState gpio_digital_out_state = 4;
inline bool ServerWrappedMessage::has_gpio_digital_out_state() const {
  return server_message_case() == kGpioDigitalOutState;
}
inline void ServerWrappedMessage::set_has_gpio_digital_out_state() {
  _oneof_case_[0] = kGpioDigitalOutState;
}
inline void ServerWrappedMessage::clear_gpio_digital_out_state() {
  if (has_gpio_digital_out_state()) {
    delete server_message_.gpio_digital_out_state_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalOutState& ServerWrappedMessage::_internal_gpio_digital_out_state() const {
  return *server_message_.gpio_digital_out_state_;
}
inline ::LabNet::Messages::Server::GpioDigitalOutState* ServerWrappedMessage::release_gpio_digital_out_state() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_state)
  if (has_gpio_digital_out_state()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::GpioDigitalOutState* temp = server_message_.gpio_digital_out_state_;
    server_message_.gpio_digital_out_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalOutState& ServerWrappedMessage::gpio_digital_out_state() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_state)
  return has_gpio_digital_out_state()
      ? *server_message_.gpio_digital_out_state_
      : *reinterpret_cast< ::LabNet::Messages::Server::GpioDigitalOutState*>(&::LabNet::Messages::Server::_GpioDigitalOutState_default_instance_);
}
inline ::LabNet::Messages::Server::GpioDigitalOutState* ServerWrappedMessage::mutable_gpio_digital_out_state() {
  if (!has_gpio_digital_out_state()) {
    clear_server_message();
    set_has_gpio_digital_out_state();
    server_message_.gpio_digital_out_state_ = CreateMaybeMessage< ::LabNet::Messages::Server::GpioDigitalOutState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_out_state)
  return server_message_.gpio_digital_out_state_;
}

// .LabNet.Messages.Server.GpioDigitalInState gpio_digital_in_state = 5;
inline bool ServerWrappedMessage::has_gpio_digital_in_state() const {
  return server_message_case() == kGpioDigitalInState;
}
inline void ServerWrappedMessage::set_has_gpio_digital_in_state() {
  _oneof_case_[0] = kGpioDigitalInState;
}
inline void ServerWrappedMessage::clear_gpio_digital_in_state() {
  if (has_gpio_digital_in_state()) {
    delete server_message_.gpio_digital_in_state_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalInState& ServerWrappedMessage::_internal_gpio_digital_in_state() const {
  return *server_message_.gpio_digital_in_state_;
}
inline ::LabNet::Messages::Server::GpioDigitalInState* ServerWrappedMessage::release_gpio_digital_in_state() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_state)
  if (has_gpio_digital_in_state()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::GpioDigitalInState* temp = server_message_.gpio_digital_in_state_;
    server_message_.gpio_digital_in_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::GpioDigitalInState& ServerWrappedMessage::gpio_digital_in_state() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_state)
  return has_gpio_digital_in_state()
      ? *server_message_.gpio_digital_in_state_
      : *reinterpret_cast< ::LabNet::Messages::Server::GpioDigitalInState*>(&::LabNet::Messages::Server::_GpioDigitalInState_default_instance_);
}
inline ::LabNet::Messages::Server::GpioDigitalInState* ServerWrappedMessage::mutable_gpio_digital_in_state() {
  if (!has_gpio_digital_in_state()) {
    clear_server_message();
    set_has_gpio_digital_in_state();
    server_message_.gpio_digital_in_state_ = CreateMaybeMessage< ::LabNet::Messages::Server::GpioDigitalInState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.gpio_digital_in_state)
  return server_message_.gpio_digital_in_state_;
}

// .LabNet.Messages.Server.Sam32InitResult sam32_init_result = 6;
inline bool ServerWrappedMessage::has_sam32_init_result() const {
  return server_message_case() == kSam32InitResult;
}
inline void ServerWrappedMessage::set_has_sam32_init_result() {
  _oneof_case_[0] = kSam32InitResult;
}
inline void ServerWrappedMessage::clear_sam32_init_result() {
  if (has_sam32_init_result()) {
    delete server_message_.sam32_init_result_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::Sam32InitResult& ServerWrappedMessage::_internal_sam32_init_result() const {
  return *server_message_.sam32_init_result_;
}
inline ::LabNet::Messages::Server::Sam32InitResult* ServerWrappedMessage::release_sam32_init_result() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.sam32_init_result)
  if (has_sam32_init_result()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::Sam32InitResult* temp = server_message_.sam32_init_result_;
    server_message_.sam32_init_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::Sam32InitResult& ServerWrappedMessage::sam32_init_result() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.sam32_init_result)
  return has_sam32_init_result()
      ? *server_message_.sam32_init_result_
      : *reinterpret_cast< ::LabNet::Messages::Server::Sam32InitResult*>(&::LabNet::Messages::Server::_Sam32InitResult_default_instance_);
}
inline ::LabNet::Messages::Server::Sam32InitResult* ServerWrappedMessage::mutable_sam32_init_result() {
  if (!has_sam32_init_result()) {
    clear_server_message();
    set_has_sam32_init_result();
    server_message_.sam32_init_result_ = CreateMaybeMessage< ::LabNet::Messages::Server::Sam32InitResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.sam32_init_result)
  return server_message_.sam32_init_result_;
}

// .LabNet.Messages.Server.UartInitResult uart_init_result = 7;
inline bool ServerWrappedMessage::has_uart_init_result() const {
  return server_message_case() == kUartInitResult;
}
inline void ServerWrappedMessage::set_has_uart_init_result() {
  _oneof_case_[0] = kUartInitResult;
}
inline void ServerWrappedMessage::clear_uart_init_result() {
  if (has_uart_init_result()) {
    delete server_message_.uart_init_result_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::UartInitResult& ServerWrappedMessage::_internal_uart_init_result() const {
  return *server_message_.uart_init_result_;
}
inline ::LabNet::Messages::Server::UartInitResult* ServerWrappedMessage::release_uart_init_result() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.uart_init_result)
  if (has_uart_init_result()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::UartInitResult* temp = server_message_.uart_init_result_;
    server_message_.uart_init_result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::UartInitResult& ServerWrappedMessage::uart_init_result() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.uart_init_result)
  return has_uart_init_result()
      ? *server_message_.uart_init_result_
      : *reinterpret_cast< ::LabNet::Messages::Server::UartInitResult*>(&::LabNet::Messages::Server::_UartInitResult_default_instance_);
}
inline ::LabNet::Messages::Server::UartInitResult* ServerWrappedMessage::mutable_uart_init_result() {
  if (!has_uart_init_result()) {
    clear_server_message();
    set_has_uart_init_result();
    server_message_.uart_init_result_ = CreateMaybeMessage< ::LabNet::Messages::Server::UartInitResult >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.uart_init_result)
  return server_message_.uart_init_result_;
}

// .LabNet.Messages.Server.UartNewData uart_new_data = 8;
inline bool ServerWrappedMessage::has_uart_new_data() const {
  return server_message_case() == kUartNewData;
}
inline void ServerWrappedMessage::set_has_uart_new_data() {
  _oneof_case_[0] = kUartNewData;
}
inline void ServerWrappedMessage::clear_uart_new_data() {
  if (has_uart_new_data()) {
    delete server_message_.uart_new_data_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::UartNewData& ServerWrappedMessage::_internal_uart_new_data() const {
  return *server_message_.uart_new_data_;
}
inline ::LabNet::Messages::Server::UartNewData* ServerWrappedMessage::release_uart_new_data() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.uart_new_data)
  if (has_uart_new_data()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::UartNewData* temp = server_message_.uart_new_data_;
    server_message_.uart_new_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::UartNewData& ServerWrappedMessage::uart_new_data() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.uart_new_data)
  return has_uart_new_data()
      ? *server_message_.uart_new_data_
      : *reinterpret_cast< ::LabNet::Messages::Server::UartNewData*>(&::LabNet::Messages::Server::_UartNewData_default_instance_);
}
inline ::LabNet::Messages::Server::UartNewData* ServerWrappedMessage::mutable_uart_new_data() {
  if (!has_uart_new_data()) {
    clear_server_message();
    set_has_uart_new_data();
    server_message_.uart_new_data_ = CreateMaybeMessage< ::LabNet::Messages::Server::UartNewData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.uart_new_data)
  return server_message_.uart_new_data_;
}

// .LabNet.Messages.Server.UartWriteDataComplete uart_write_data_complete = 9;
inline bool ServerWrappedMessage::has_uart_write_data_complete() const {
  return server_message_case() == kUartWriteDataComplete;
}
inline void ServerWrappedMessage::set_has_uart_write_data_complete() {
  _oneof_case_[0] = kUartWriteDataComplete;
}
inline void ServerWrappedMessage::clear_uart_write_data_complete() {
  if (has_uart_write_data_complete()) {
    delete server_message_.uart_write_data_complete_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::UartWriteDataComplete& ServerWrappedMessage::_internal_uart_write_data_complete() const {
  return *server_message_.uart_write_data_complete_;
}
inline ::LabNet::Messages::Server::UartWriteDataComplete* ServerWrappedMessage::release_uart_write_data_complete() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.uart_write_data_complete)
  if (has_uart_write_data_complete()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::UartWriteDataComplete* temp = server_message_.uart_write_data_complete_;
    server_message_.uart_write_data_complete_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::UartWriteDataComplete& ServerWrappedMessage::uart_write_data_complete() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.uart_write_data_complete)
  return has_uart_write_data_complete()
      ? *server_message_.uart_write_data_complete_
      : *reinterpret_cast< ::LabNet::Messages::Server::UartWriteDataComplete*>(&::LabNet::Messages::Server::_UartWriteDataComplete_default_instance_);
}
inline ::LabNet::Messages::Server::UartWriteDataComplete* ServerWrappedMessage::mutable_uart_write_data_complete() {
  if (!has_uart_write_data_complete()) {
    clear_server_message();
    set_has_uart_write_data_complete();
    server_message_.uart_write_data_complete_ = CreateMaybeMessage< ::LabNet::Messages::Server::UartWriteDataComplete >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.uart_write_data_complete)
  return server_message_.uart_write_data_complete_;
}

// .LabNet.Messages.Server.OnlyOneConnectionAllowed only_one_connection = 10;
inline bool ServerWrappedMessage::has_only_one_connection() const {
  return server_message_case() == kOnlyOneConnection;
}
inline void ServerWrappedMessage::set_has_only_one_connection() {
  _oneof_case_[0] = kOnlyOneConnection;
}
inline void ServerWrappedMessage::clear_only_one_connection() {
  if (has_only_one_connection()) {
    delete server_message_.only_one_connection_;
    clear_has_server_message();
  }
}
inline const ::LabNet::Messages::Server::OnlyOneConnectionAllowed& ServerWrappedMessage::_internal_only_one_connection() const {
  return *server_message_.only_one_connection_;
}
inline ::LabNet::Messages::Server::OnlyOneConnectionAllowed* ServerWrappedMessage::release_only_one_connection() {
  // @@protoc_insertion_point(field_release:LabNet.Messages.Server.ServerWrappedMessage.only_one_connection)
  if (has_only_one_connection()) {
    clear_has_server_message();
      ::LabNet::Messages::Server::OnlyOneConnectionAllowed* temp = server_message_.only_one_connection_;
    server_message_.only_one_connection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::LabNet::Messages::Server::OnlyOneConnectionAllowed& ServerWrappedMessage::only_one_connection() const {
  // @@protoc_insertion_point(field_get:LabNet.Messages.Server.ServerWrappedMessage.only_one_connection)
  return has_only_one_connection()
      ? *server_message_.only_one_connection_
      : *reinterpret_cast< ::LabNet::Messages::Server::OnlyOneConnectionAllowed*>(&::LabNet::Messages::Server::_OnlyOneConnectionAllowed_default_instance_);
}
inline ::LabNet::Messages::Server::OnlyOneConnectionAllowed* ServerWrappedMessage::mutable_only_one_connection() {
  if (!has_only_one_connection()) {
    clear_server_message();
    set_has_only_one_connection();
    server_message_.only_one_connection_ = CreateMaybeMessage< ::LabNet::Messages::Server::OnlyOneConnectionAllowed >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:LabNet.Messages.Server.ServerWrappedMessage.only_one_connection)
  return server_message_.only_one_connection_;
}

inline bool ServerWrappedMessage::has_server_message() const {
  return server_message_case() != SERVER_MESSAGE_NOT_SET;
}
inline void ServerWrappedMessage::clear_has_server_message() {
  _oneof_case_[0] = SERVER_MESSAGE_NOT_SET;
}
inline ServerWrappedMessage::ServerMessageCase ServerWrappedMessage::server_message_case() const {
  return ServerWrappedMessage::ServerMessageCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Server
}  // namespace Messages
}  // namespace LabNet

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_LabNetServerMessages_2eproto
